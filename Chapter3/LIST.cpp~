#include "LIST.h"

List::List(){
    Element=NULL;
    Next=NULL;
}

/*Return true if L is empty*/
bool IsEmpty(PList L){
    return L->Next==NULL;
}

/*Return true if P is the last Position in List L*/
/*Parameter L is unused in this implementation*/
bool IsLast(Position P,PList L){
    return P->Next==NULL;
}

/*Return Position of X in L, NULL if not found*/
Position Find(ElementType X, PList L){
    Position P;

    P=L->Next;
    while(P!=NULL && P->Element!=X){
        P=P->Next;
    }
    return P;
}

/*If X is not found, then Next field of returned*/
/*Position is NULL*/
/*Assume a header*/
Position FindPrevious(ElementType X, PList L){
    Position P=L;

    while(P->Next!=NULL && P->Next->Element!=X)
        P=P->Next;

    return P;
}

/*Delete first occurrence of X from a list*/
/*Assume use of a header node*/
void Delete(ElementType X,PList L){
    Position P,TmpCell;

    P=FindPrevious(X,L);

    if(!IsLast(P,L)){
        TmpCell=P->Next;
	P->Next=TmpCell->Next;
	delete TmpCell;
    }
}

/*Insert (after legal position P)*/
/*Header implementation assumed*/
/*Parameter L is unused in this implementation*/
void Insert(ElementType X,PList L,Position P){
    Position TmpCell;

    TmpCell=new List;
    if(TmpCell==NULL)
        FatalError("Out of Space!");

    TmpCell->Element=X;
    TmpCell->Next=P->Next;
    P->Next=TmpCell;
}

void DeleteList(PList L){
    Position P,Tmp;

    P=L->Next;
    L->Next=NULL;
    while(P!=NULL){
        Tmp=P->Next;
        delete P;
	P=Tmp;
    }
}
